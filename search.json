[{"title":"Android|Jetpack系列之Lifecycle","path":"/2023/04/10/Android-Jetpack系列之Lifecycle/","content":"Lifecycle介绍Lifecycle可以让某一个类变成Activity、Fragment的生命周期观察者类，监听其生命周期的变化并可以做出响应。Lifecycle使得代码更有条理性、精简、易于维护。 Lifecycle中主要有两个角色： LifecycleOwner: 生命周期拥有者，如Activity&#x2F;Fragment等类都实现了该接口并通过getLifecycle()获得Lifecycle，进而可通过addObserver()添加观察者。 LifecycleObserver: 生命周期观察者，实现该接口后就可以添加到Lifecycle中，从而在被观察者类生命周期发生改变时能马上收到通知。 实现LifecycleOwner的生命周期拥有者可与实现LifecycleObserver的观察者完美配合。 场景case假设我们有一个在屏幕上显示设备位置的 Activity，我们可能会像下面这样实现： 123456789101112131415161718192021222324252627282930313233343536internal class MyLocationListener( private val context: Context, private val callback: (Location) -&gt; Unit) &#123; fun start() &#123; // connect to system location service &#125; fun stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity : AppCompatActivity() &#123; private lateinit var myLocationListener: MyLocationListener override fun onCreate(...) &#123; myLocationListener = MyLocationListener(this) &#123; location -&gt; // update UI &#125; &#125; public override fun onStart() &#123; super.onStart() myLocationListener.start() // manage other components that need to respond // to the activity lifecycle &#125; public override fun onStop() &#123; super.onStop() myLocationListener.stop() // manage other components that need to respond // to the activity lifecycle &#125;&#125; 注：上面代码来自官方示例~ 我们可以在Activity 或 Fragment 的生命周期方法(示例中的onStart/onStop)中直接对依赖组件进行操作。但是，这样会导致代码条理性很差且不易扩展。那么有了Lifecycle，可以将依赖组件的代码从Activity/Fragment生命周期方法中移入组件本身中。 Lifecycle使用根目录下build.gradle: 1234567891011allprojects &#123; repositories &#123; google() // Gradle小于4.1时，使用下面的声明替换: // maven &#123; // url &#x27;https://maven.google.com&#x27; // &#125; // An alternative URL is &#x27;https://dl.google.com/dl/android/maven2/&#x27; &#125;&#125; app下的build.gradle: 12345678910111213141516171819202122232425262728293031dependencies &#123; def lifecycle_version = &quot;2.3.1&quot; def arch_version = &quot;2.1.0&quot; // ViewModel implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot; // LiveData implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot; // Lifecycles only (without ViewModel or LiveData) implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot; // Saved state module for ViewModel implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot; // Annotation processor kapt &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot; // 可选 - 如果使用Java8,使用下面这个代替lifecycle-compiler implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot; // 可选 - 在Service中使用Lifecycle implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot; // 可选 - Application中使用Lifecycle implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot; // 可选 - ReactiveStreams support for LiveData implementation &quot;androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version&quot; // 可选 - Test helpers for LiveData testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;&#125; Activity&#x2F;Fragment中使用Lifecycle首先先来实现LifecycleObserver观察者： 123456789101112open class MyLifeCycleObserver : LifecycleObserver &#123; @OnLifecycleEvent(value = Lifecycle.Event.ON_START) fun connect(owner: LifecycleOwner) &#123; Log.e(JConsts.LIFE_TAG, &quot;Lifecycle.Event.ON_CREATE:connect&quot;) &#125; @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP) fun disConnect() &#123; Log.e(JConsts.LIFE_TAG, &quot;Lifecycle.Event.ON_DESTROY:disConnect&quot;) &#125;&#125; 在方法上，我们使用了@OnLifecycleEvent注解，并传入了一种生命周期事件，其类型可以为ON_CREATE、ON_START、ON_RESUME、ON_PAUSE、ON_STOP、ON_DESTROY、ON_ANY中的一种。其中前6个对应Activity中对应生命周期的回调，最后一个ON_ANY可以匹配任何生命周期回调。所以，上述代码中的connect()、disConnect()方法分别应该在Activity的onStart()、onStop()中触发时执行。接着来实现我们的Activity: 123456789101112131415161718192021222324252627282930313233343536class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onCreate&quot;) //添加LifecycleObserver观察者 lifecycle.addObserver(MyLifeCycleObserver()) &#125; override fun onStart() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onStart&quot;) super.onStart() &#125; override fun onResume() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onResume&quot;) super.onResume() &#125; override fun onPause() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onPause&quot;) super.onPause() &#125; override fun onStop() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onStop&quot;) super.onStop() &#125; override fun onDestroy() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onDestroy&quot;) super.onDestroy() &#125;&#125; 可以看到在Activity中我们只是在onCreate()中添加了这么一行代码： 1lifecycle.addObserver(MyLifeCycleObserver()) 其中getLifecycle()是LifecycleOwner中的方法，返回的是Lifecycle对象，并通过addObserver()的方式添加了我们的生命周期观察者。接下来看执行结果，启动Activity: 12345672021-06-30 20:57:58.038 11257-11257/ E/Lifecycle_Study: ACTIVITY:onCreate//onStart() 传递到 MyLifeCycleObserver: connect()2021-06-30 20:57:58.048 11257-11257/ E/Lifecycle_Study: ACTIVITY:onStart2021-06-30 20:57:58.049 11257-11257/ E/Lifecycle_Study: Lifecycle.Event.ON_START:connect2021-06-30 20:57:58.057 11257-11257/ E/Lifecycle_Study: ACTIVITY:onResume 关闭Activity: 12345672021-06-30 20:58:02.646 11257-11257/ E/Lifecycle_Study: ACTIVITY:onPause//onStop() 传递到 MyLifeCycleObserver: disConnect()2021-06-30 20:58:03.149 11257-11257/ E/Lifecycle_Study: ACTIVITY:onStop2021-06-30 20:58:03.161 11257-11257/ E/Lifecycle_Study: Lifecycle.Event.ON_STOP:disConnect2021-06-30 20:58:03.169 11257-11257/ E/Lifecycle_Study: ACTIVITY:onDestroy 可以看到我们的MyLifeCycleObserver中的connect()/disconnect()方法的确是分别在Activity的onStart()/onStop()回调时执行的。 自定义LifecycleOwner在AndroidX中的Activity、Fragmen实现了LifecycleOwner，通过getLifecycle()能获取到Lifecycle实例(Lifecycle是抽象类，实例化的是子类LifecycleRegistry)。 12345678public interface LifecycleOwner &#123; @NonNull Lifecycle getLifecycle();&#125;public class LifecycleRegistry extends Lifecycle &#123;&#125; 如果我们想让一个自定义类成为LifecycleOwner，可以直接实现LifecycleOwner： 12345678910111213141516171819202122232425262728293031323334class CustomLifeCycleOwner : LifecycleOwner &#123; private lateinit var registry: LifecycleRegistry fun init() &#123; registry = LifecycleRegistry(this) //通过setCurrentState来完成生命周期的传递 registry.currentState = Lifecycle.State.CREATED &#125; fun onStart() &#123; registry.currentState = Lifecycle.State.STARTED &#125; fun onResume() &#123; registry.currentState = Lifecycle.State.RESUMED &#125; fun onPause() &#123; registry.currentState = Lifecycle.State.STARTED &#125; fun onStop() &#123; registry.currentState = Lifecycle.State.CREATED &#125; fun onDestroy() &#123; registry.currentState = Lifecycle.State.DESTROYED &#125; override fun getLifecycle(): Lifecycle &#123; //返回LifecycleRegistry实例 return registry &#125;&#125; 首先我们的自定义类实现了接口LifecycleOwner，并在getLifecycle()返回LifecycleRegistry实例，接下来就可以通过LifecycleRegistry#setCurrentState来传递生命周期状态了。到目前为止，已经完成了大部分工作，最后也是需要去添加LifecycleObserver: 123456789101112131415161718192021222324252627282930313233343536373839404142434445//注意：这里继承的是Activity，本身并不具备LifecycleOwner能力class MainActivity : Activity() &#123; val owner: CustomLifeCycleOwner = CustomLifeCycleOwner() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onCreate&quot;) //自定义LifecycleOwner owner.init() //添加LifecycleObserver owner.lifecycle.addObserver(MyLifeCycleObserver()) &#125; override fun onStart() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onStart&quot;) super.onStart() owner.onStart() &#125; override fun onResume() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onResume&quot;) super.onResume() owner.onResume() &#125; override fun onPause() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onPause&quot;) super.onPause() owner.onPause() &#125; override fun onStop() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onStop&quot;) super.onStop() owner.onStop() &#125; override fun onDestroy() &#123; Log.e(JConsts.LIFE_TAG, &quot;$ACTIVITY:onDestroy&quot;) super.onDestroy() owner.onDestroy() &#125;&#125; 很简单，主要是在onCreate()里实例化LifecycleOwner并调用init()完成LifecycleRegistry实例化。接着跟androidX中的Activity一样了，通过getLifecycle()得到LifecycleRegistry实例并通过addObserver()注册LifecycleObserver，最后代码执行结果跟上面的结果一致，不再重复贴了。 Application中使用Lifecycle首先记得要先引入对应依赖： 1implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot; 然后代码编写如下： 1234567891011121314151617181920212223242526//MyApplicationLifecycleObserver.ktclass MyApplicationLifecycleObserver : LifecycleObserver &#123; @OnLifecycleEvent(value = Lifecycle.Event.ON_START) fun onAppForeground() &#123; Log.e(JConsts.LIFE_APPLICATION_TAG, &quot;onAppForeground&quot;) &#125; @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP) fun onAppBackground() &#123; Log.e(JConsts.LIFE_APPLICATION_TAG, &quot;onAppBackground&quot;) &#125;&#125;//MyApplication.ktclass MyApplication : Application() &#123; override fun onCreate() &#123; super.onCreate() ProcessLifecycleOwner.get().lifecycle.addObserver(MyApplicationLifecycleObserver()) &#125;&#125;//manifest.xml&lt;application android:name=&quot;.MyApplication&quot;&gt;&lt;/application&gt; 启动应用： 12021-06-30 21:55:11.657 14292-14292/ E/Lifecycle_App_Study: onAppForeground 点击Home键，应用切到后台： 12021-06-30 21:55:35.741 14292-14292/ E/Lifecycle_App_Study: onAppBackground 再切回来： 12021-06-30 21:55:11.657 14292-14292/ E/Lifecycle_App_Study: onAppForeground ProcessLifecycleOwner可以很方便地帮助我们检测App前后台状态。 Service中使用Lifecycle在Service中使用Lifecycle同样需要先引入依赖： 1implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot; 然后继承LifecycleService： 1234567891011121314151617181920212223242526272829303132333435//MyService.ktclass MyService : LifecycleService() &#123; override fun onCreate() &#123; Log.e(JConsts.SERVICE, &quot;Service:onCreate&quot;) super.onCreate() lifecycle.addObserver(MyLifeCycleObserver()) &#125; override fun onStart(intent: Intent?, startId: Int) &#123; Log.e(JConsts.SERVICE, &quot;Service:onStart&quot;) super.onStart(intent, startId) &#125; override fun onDestroy() &#123; Log.e(JConsts.SERVICE, &quot;Service:onDestroy&quot;) super.onDestroy() &#125;&#125;//MainActivity.kt /** * 启动Service */ private fun startLifecycleService() &#123; val intent = Intent(this, MyService::class.java) startService(intent) &#125; /** * 关闭Service */ fun closeService(view: View) &#123; val intent = Intent(this, MyService::class.java) stopService(intent) &#125; LifecycleService中实现了LifecycleOwner接口，所以子类中可以直接通过getLifecycle()添加生命周期Observer，在Activity中启动Service: 12342021-07-01 14:10:09.703 7606-7606/ E/SERVICE: Service:onCreate2021-07-01 14:10:09.709 7606-7606/ E/SERVICE: Service:onStart2021-07-01 14:10:09.712 7606-7606/ E/SERVICE: Lifecycle.Event.ON_START:connect 操作停止Service： 122021-07-01 14:10:13.062 7606-7606/ E/SERVICE: Service:onDestroy2021-07-01 14:10:13.063 7606-7606/ E/SERVICE: Lifecycle.Event.ON_STOP:disConnect 结果也很简单，这里注意一点：因为Service中没有onPause/onStop状态，所以在Service#onDestroy()之后，LifecycleService 里会同时分发Lifecycle.Event.ON_STOP、Lifecycle.Event.ON_DESTROY两个Event，所以我们的观察者监听哪个都是可以的。 完整代码地址完整代码地址参见：Jetpack Lifecycle例子 源码解析Lifecycle.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public abstract class Lifecycle &#123; @NonNull AtomicReference&lt;Object&gt; mInternalScopeRef = new AtomicReference&lt;&gt;(); @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); @MainThread @NonNull public abstract State getCurrentState(); //生命周期事件 对应于Activity/Fragment生命周期 public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, /** * An constant that can be used to match all events. */ ON_ANY &#125; //生命周期状态 public enum State &#123; //onStop()之后，此状态是LifecycleOwner终态，Lifecycle不在分发Event DESTROYED, //初始化状态 INITIALIZED, //onCreate()或onStop()之后 CREATED, //onStart()或onPause()之后 STARTED, //onResume()之后 RESUMED; public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125;&#125; Lifecycle中的两个重要枚举： Event：生命周期事件，包括ON_CREATE、ON_START、ON_RESUME、ON_PAUSE、ON_STOP、ON_DESTROY、ON_ANY，对应于Activity/Fragment生命周期。 State：生命周期状态，包括DESTROYED、INITIALIZED、CREATED、STARTED、RESUMED，Event的改变会使得State也发生改变。 两者关系如下： Event生命周期事件分发&amp;接收我们的Activity继承自AppCompatActivity，继续往上找AppCompatActivity的父类，最终能找到了ComponentActivity： 123456789101112131415161718192021222324252627282930313233public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner&#123;//省略其他代码 只显示Lifecycle相关代码private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //将生命周期的事件传递交给ReportFragment ReportFragment.injectIfNeededIn(this); if (mContentLayoutId != 0) &#123; setContentView(mContentLayoutId); &#125; &#125;&#125; @CallSuper @Override protected void onSaveInstanceState(@NonNull Bundle outState) &#123; Lifecycle lifecycle = getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).setCurrentState(Lifecycle.State.CREATED); &#125; super.onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125;&#125; 可以看到getLifecycle()返回的是LifecycleRegistry实例，并且在onSaveInstanceState()中分发了Lifecycle.State.CREATED状态，但是其他生命周期回调中并没有写了呀，嗯哼？再细看一下，onCreate()中有个ReportFragment.injectIfNeededIn(this)，直接进去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class ReportFragment extends Fragment &#123; private static final String REPORT_FRAGMENT_TAG = &quot;androidx.lifecycle&quot; + &quot;.LifecycleDispatcher.report_fragment_tag&quot;; public static void injectIfNeededIn(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= 29) &#123; activity.registerActivityLifecycleCallbacks( new LifecycleCallbacks()); &#125; android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125; &#125; @SuppressWarnings(&quot;deprecation&quot;) static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) &#123; //已经被标注为@Deprecated if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125; static ReportFragment get(Activity activity) &#123; return (ReportFragment) activity.getFragmentManager().findFragmentByTag( REPORT_FRAGMENT_TAG); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); &#125; @Override public void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); &#125; @Override public void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP); &#125; @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won&#x27;t leak reference to an activity mProcessListener = null; &#125; private void dispatch(@NonNull Lifecycle.Event event) &#123; if (Build.VERSION.SDK_INT &lt; 29) &#123; dispatch(getActivity(), event); &#125; &#125; //API29及以上直接使用Application.ActivityLifecycleCallbacks来监听生命周期 static class LifecycleCallbacks implements Application.ActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle bundle) &#123; &#125; @Override public void onActivityPostCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; dispatch(activity, Lifecycle.Event.ON_CREATE); &#125; @Override public void onActivityStarted(@NonNull Activity activity) &#123; &#125; @Override public void onActivityPostStarted(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_START); &#125; @Override public void onActivityResumed(@NonNull Activity activity) &#123; &#125; @Override public void onActivityPostResumed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_RESUME); &#125; @Override public void onActivityPrePaused(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_PAUSE); &#125; @Override public void onActivityPaused(@NonNull Activity activity) &#123; &#125; @Override public void onActivityPreStopped(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_STOP); &#125; @Override public void onActivityStopped(@NonNull Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle bundle) &#123; &#125; @Override public void onActivityPreDestroyed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_DESTROY); &#125; @Override public void onActivityDestroyed(@NonNull Activity activity) &#123; &#125; &#125;&#125; 代码的逻辑很清晰，主要通过一个透明的Fragment来分发生命周期事件，这样对于Activity来说是无侵入的。分成两部分逻辑：当API&gt;&#x3D;29时，直接使用Application.ActivityLifecycleCallbacks来分发生命周期事件；而当API&lt;29时，在Fragment的生命周期回调中进行了事件分发。但殊途同归，两者最终都会走到dispatch(Activity activity, Lifecycle.Event event)方法中，该方法内部又调用了LifecycleRegistry#handleLifecycleEvent(event)，我们继续去看该方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839//LifecycleRegistry.javapublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException(&quot;Unexpected event value &quot; + event);&#125;private void moveToState(State next) &#123; //如果与当前状态一致 直接返回 if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; getStateAfter()根据传入的Event返回State，比如ON_CREATE、ON_STOP之后对应的是CREATED，这里再把之前的这张图贴出来就一目了然了:得到state后，传入了moveToState()中，方法内部做了一些校验判断，然后又走到了sync()中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Custom list that keeps observers and can handle removals / additions during traversal. * * Invariant: at any moment of time for observer1 &amp; observer2: * if addition_order(observer1) &lt; addition_order(observer2), then * state(observer1) &gt;= state(observer2), */private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;();private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; throw new IllegalStateException(&quot;LifecycleOwner of this LifecycleRegistry is already&quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot;); &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125;private boolean isSynced() &#123; if (mObserverMap.size() == 0) &#123; return true; &#125; State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; //最新状态和最老状态一致 且 当前状态与最新状态一致(传进来的状态与队列中的状态一致) 两个条件都符合时，即认为是状态同步完 return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;&#125;private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125;&#125;private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125;&#125; FastSafeIterableMap&lt; LifecycleObserver, ObserverWithState&gt;实现了在遍历过程中的安全增删元素。LifecycleObserver是观察者，ObserverWithState则是对观察者的封装。isSynced()用来判断所有的观察者状态是否同步完，如果队列中新老状态不一致或者传进来的State与队列中的不一致，会继续往下走进入while循环，如果传进来的状态小于队列中的最大状态，backwardPass()将队列中所有大于当前状态的观察者同步到当前状态；如果存在队列中的状态小于当前状态的，那么通过forwardPass()将队列中所有小于当前状态的观察者同步到当前状态。同步过程都会执行到ObserverWithState#dispatchEvent()方法： 12345678910111213141516static class ObserverWithState &#123; State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; ObserverWithState#dispatchEvent()中调用了mLifecycleObserver.onStateChanged()，这个mLifecycleObserver是LifecycleEventObserver类型(父类是接口LifecycleObserver)，在构造方法中通过Lifecycling.lifecycleEventObserver()创建的，最终返回的是ReflectiveGenericLifecycleObserver： 123456789101112131415//ReflectiveGenericLifecycleObserver.javaclass ReflectiveGenericLifecycleObserver implements LifecycleEventObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; ClassesInfoCache内部存了所有观察者的回调信息，CallbackInfo是当前观察者的回调信息。getInfo()中如果从内存mCallbackMap中有对应回调信息，直接返回；否则通过createInfo()内部解析注解OnLifecycleEvent对应的方法并最终生成CallbackInfo返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//ClassesInfoCache.javaCallbackInfo getInfo(Class&lt;?&gt; klass) &#123; CallbackInfo existing = mCallbackMap.get(klass); if (existing != null) &#123; return existing; &#125; existing = createInfo(klass, null); return existing;&#125;private void verifyAndPutHandler(Map&lt;MethodReference, Lifecycle.Event&gt; handlers, MethodReference newHandler, Lifecycle.Event newEvent, Class&lt;?&gt; klass) &#123; Lifecycle.Event event = handlers.get(newHandler); if (event == null) &#123; handlers.put(newHandler, newEvent); &#125;&#125;private CallbackInfo createInfo(Class&lt;?&gt; klass, @Nullable Method[] declaredMethods) &#123; Class&lt;?&gt; superclass = klass.getSuperclass(); Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = new HashMap&lt;&gt;(); if (superclass != null) &#123; CallbackInfo superInfo = getInfo(superclass); if (superInfo != null) &#123; handlerToEvent.putAll(superInfo.mHandlerToEvent); &#125; &#125; Class&lt;?&gt;[] interfaces = klass.getInterfaces(); for (Class&lt;?&gt; intrfc : interfaces) &#123; for (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : getInfo( intrfc).mHandlerToEvent.entrySet()) &#123; verifyAndPutHandler(handlerToEvent, entry.getKey(), entry.getValue(), klass); &#125; &#125; Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass); boolean hasLifecycleMethods = false; //遍历寻找OnLifecycleEvent注解对应的方法 for (Method method : methods) &#123; OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation == null) &#123; continue; &#125; hasLifecycleMethods = true; Class&lt;?&gt;[] params = method.getParameterTypes(); int callType = CALL_TYPE_NO_ARG; if (params.length &gt; 0) &#123; callType = CALL_TYPE_PROVIDER; //第一个方法参数必须是LifecycleOwner if (!params[0].isAssignableFrom(LifecycleOwner.class)) &#123; throw new IllegalArgumentException( &quot;invalid parameter type. Must be one and instanceof LifecycleOwner&quot;); &#125; &#125; Lifecycle.Event event = annotation.value(); if (params.length &gt; 1) &#123; callType = CALL_TYPE_PROVIDER_WITH_EVENT; //第2个参数必须是Lifecycle.Event if (!params[1].isAssignableFrom(Lifecycle.Event.class)) &#123; throw new IllegalArgumentException( &quot;invalid parameter type. second arg must be an event&quot;); &#125; //当有2个参数时，注解必须是Lifecycle.Event.ON_ANY if (event != Lifecycle.Event.ON_ANY) &#123; throw new IllegalArgumentException( &quot;Second arg is supported only for ON_ANY value&quot;); &#125; &#125; if (params.length &gt; 2) &#123; throw new IllegalArgumentException(&quot;cannot have more than 2 params&quot;); &#125; MethodReference methodReference = new MethodReference(callType, method); verifyAndPutHandler(handlerToEvent, methodReference, event, klass); &#125; CallbackInfo info = new CallbackInfo(handlerToEvent); mCallbackMap.put(klass, info); mHasLifecycleMethods.put(klass, hasLifecycleMethods); return info;&#125;//CallbackInfo.javastatic class CallbackInfo &#123; final Map&lt;Lifecycle.Event, List&lt;MethodReference&gt;&gt; mEventToHandlers; final Map&lt;MethodReference, Lifecycle.Event&gt; mHandlerToEvent; CallbackInfo(Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent) &#123; mHandlerToEvent = handlerToEvent; mEventToHandlers = new HashMap&lt;&gt;(); for (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : handlerToEvent.entrySet()) &#123; Lifecycle.Event event = entry.getValue(); List&lt;MethodReference&gt; methodReferences = mEventToHandlers.get(event); if (methodReferences == null) &#123; methodReferences = new ArrayList&lt;&gt;(); mEventToHandlers.put(event, methodReferences); &#125; methodReferences.add(entry.getKey()); &#125; &#125; void invokeCallbacks(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target); invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event, target);&#125;private static void invokeMethodsForEvent(List&lt;MethodReference&gt; handlers, LifecycleOwner source, Lifecycle.Event event, Object mWrapped) &#123; if (handlers != null) &#123; for (int i = handlers.size() - 1; i &gt;= 0; i--) &#123; handlers.get(i).invokeCallback(source, event, mWrapped); &#125; &#125;&#125; 最终调用到了MethodReference#invokeCallback()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//MethodReference.javastatic class MethodReference &#123; final int mCallType; final Method mMethod; MethodReference(int callType, Method method) &#123; mCallType = callType; mMethod = method; mMethod.setAccessible(true); &#125; void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; //noinspection TryWithIdenticalCatches try &#123; //OnLifecycleEvent注解对应的方法入参 switch (mCallType) &#123; //没有参数 case CALL_TYPE_NO_ARG: mMethod.invoke(target); break; //一个参数：LifecycleOwner case CALL_TYPE_PROVIDER: mMethod.invoke(target, source); break; //两个参数：LifecycleOwner，Event case CALL_TYPE_PROVIDER_WITH_EVENT: mMethod.invoke(target, source, event); break; &#125; &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(&quot;Failed to call observer method&quot;, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; MethodReference that = (MethodReference) o; return mCallType == that.mCallType &amp;&amp; mMethod.getName().equals(that.mMethod.getName()); &#125; @Override public int hashCode() &#123; return 31 * mCallType + mMethod.getName().hashCode(); &#125;&#125; 根据不同入参个数通过反射来初始化并执行观察者相应方法，整个流程就从LifecycleOwner中的生命周期Event传到了LifecycleObserver中对应的方法。到这里整个流程就差不多结束了，最后是LifecycleOwner的子类LifecycleRegistry添加观察者的过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//LifecycleRegistry.java@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); //key是LifecycleObserver,value是ObserverWithState ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //如果已经存在，直接返回 if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; //目标State State targetState = calculateTargetState(observer); mAddingObserverCounter++; //循环遍历，将目标State连续同步到Observer中 while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125;private State calculateTargetState(LifecycleObserver observer) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); State siblingState = previous != null ? previous.getValue().mState : null; State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; return min(min(mState, siblingState), parentState);&#125; 添加观察者，并通过while循环，将最新的State状态连续同步到Observer中，虽然可能添加Observer比LifecyleOwner分发事件晚，但是依然能收到所有事件，类似于事件总线的粘性事件。最后画一下整体的类图关系： 参考【1】https://developer.android.com/topic/libraries/architecture/lifecycle【2】Android架构组件LifecycleRegistry 源码分析","tags":["Jetpack、Lifecycle"],"categories":["Jetpack"]},{"title":"Android Studio中通过SSH Key上传代码到Github","path":"/2023/04/10/Android-Studio中通过SSH-Key上传代码到Github/","content":"GitHub中的SSH配置我们在日常开发中请求登录后，服务端会根据登录信息生成一个该用户的唯一标识，如sessionId或者token，后续客户端请求其他接口时，只需要将该标识传给服务端即可，而不用每次再重新登录。 类似的，如果往Github上push项目的时候，不想每次都输入账号密码，那么就可以采用\tSSH的方式，只需要在Github自己账号下配置一个SSH Key即可！ 一 检查SSH Key信息在控制台打开ssh目录： 1cd ~/.ssh 然后输入ls命令查看该目录下是否有文件，如在我的电脑中：因为我之前生成过，所以这里直接列出了之前生成的SSH Key，其中id_ed25519是私钥，id_ed25519.pub是公钥。通过open ~/.ssh命令打开该目录，可以看到对应文件： 二 生成SSH Key信息上一节是存在SSH Key 的情况，如果之前没有生成过，则需要我们先生成一下： 1ssh-keygen -t ed25519 -C &quot;xxx@xxx.com&quot; t ：指定要使用的密钥算法类型，可选dsa | ecdsa | ed25519 | rsa非对称加密算法其中的一种。 C : 用于在生成的SSH 密钥文件中添加注释信息，方便用户识别和管理，这个注释信息会被添加到生成的 SSH 密钥文件的结尾处，一般使用Email 邮箱来添加注释信息。 现在我把之前的.ssh目录下的签名信息全部删除，重新生成一遍，如执行下面的命令： 1ssh-keygen -t ed25519 -C &quot;504091986@qq.com&quot; 一路点击回车，执行结果： 这样会在 .ssh 目录重新生成两个文件：id_id_ed25519和id_id_ed25519.pub 其中id_id_ed25519 文件是私有密钥，id_id_ed25519.pub是公开密钥。 三 获取SSH Key里的公钥内容执行下面的命令： cat ~&#x2F;.ssh&#x2F;id_ed25519.pub 执行结果： 1ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOZQf7wE5XxUB3YnEZ4MjqA7F8aze2rq5jM0uo3xxxxx 504091986@qq.com 上面就是我们生成的公钥了，当然也可以直接进入的.ssh目录下，打开 id_ed25519.pub 文件，也可以看到公钥中的内容。 四 Github上配置公钥打开对应的项目工程，然后按下面的步骤配置：如上面截图所示，依次点击Settings -&gt; Deploy keys，在显示的页面上，Title 随便起个名字，重点是 Key，将上一节生成的公钥拷贝到这里，下面的 Allow writes acess 打上勾，点击 Add key 按钮就可以了。 验证是否设置成功 1ssh -T git@github.com 如果返回下面的提示则表示设置成功了： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 后续就可以在Android Studio中直接通过git操作远程代码仓库了。","tags":["SSH Key配置"],"categories":["工具"]},{"title":"Android | 深入理解RecyclerView缓存机制","path":"/2023/04/10/Android-深入理解RecyclerView缓存机制/","content":"RecyclerView在项目中的使用已经很普遍了，可以说是项目中最高频使用的一个控件了。除了布局灵活性、丰富的动画，RecyclerView还有优秀的缓存机制，本文尝试通过源码深入了解一下RecyclerView中的缓存机制。 写在前面RecyclerView 是通过内部类 Recycler 管理的缓存，那么 Recycler 中缓存的是什么？我们知道 RecyclerView 在存在大量数据时依然可以滑动的如丝滑般顺畅，而 RecyclerView 本身是一个 ViewGroup ，那么滑动时避免不了添加或移除子View(子View通过RecyclerView#Adapter中的onCreateViewHolder创建)，如果每次使用子View都要去重新创建，肯定会影响滑动的流 畅性，所以 RecyclerView 通过 Recycler 来缓存的是 ViewHolder (内部包含子View)，这样在滑动时可以复用子View，某些条件下还可以复用子View绑定的数据。所以本质上缓存是为了减少重复绘制View和绑定数据的时间，从而提高了滑动时的性能。 四级缓存Recycler缓存ViewHolder对象有4个等级，优先级从高到底依次为： mAttachedScrap：ArrayList&lt; ViewHolder&gt;类型 mCachedViews：ArrayList&lt; ViewHolder&gt;类型 mViewCacheExtension：ViewCacheExtension类型 mRecyclerPool：RecycledViewPool类型 注：官方上把mAttachedScrap、mCachedViews当成一级了，为了方便区分，本文还是把他们当成两级缓存。 缓存 涉及对象 作用 重新创建视图View(onCreateViewHolder) 重新绑定数据(onBindViewHolder) 一级缓存 mAttachedScrap 缓存屏幕中可见范围的ViewHolder false false 二级缓存 mCachedViews 缓存滑动时即将与RecyclerView分离的ViewHolder，按子View的position或id缓存，默认最多存放2个 false false 三级缓存 mViewCacheExtension 开发者自行实现的缓存 - - 四级缓存 mRecyclerPool ViewHolder缓存池，本质上是一个SparseArray，其中key是ViewType(int类型)，value存放的是 ArrayList&lt; ViewHolder&gt;，默认每个ArrayList中最多存放5个ViewHolder false true RecyclerView 滑动时会触发 onTouchEvent#onMove ，回收及复用 ViewHolder 在这里就会开始。我们知道设置 RecyclerView 时需要设置 LayoutManager， LayoutManager 负责 RecyclerView 的布局，包含对 ItemView 的获取与复用。以LinearLayoutManager为例，当 RecyclerView 重新布局时会依次执行下面几个方法： onLayoutChildren()：对RecyclerView进行布局的入口方法 fill(): 负责对剩余空间不断地填充，调用的方法是layoutChunk() layoutChunk()：负责填充View,该View最终是通过在缓存类Recycler中找到合适的View 上述的整个调用链：**onLayoutChildren()-&gt;fill()-&gt;layoutChunk()-&gt;next()-&gt;getViewForPosition()**，getViewForPosition()即是是从RecyclerView的回收机制实现类Recycler中获取合适的View，下面主要就来从看这个Recycler#getViewForPosition()的实现。 12345678@NonNullpublic View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125; 他们都会执行tryGetViewHolderForPositionByDeadline函数，继续跟进去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//根据传入的position获取ViewHolderViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; ---------省略---------- boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; //预布局 属于特殊情况 从mChangedScrap中获取ViewHolder if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; if (holder == null) &#123; //1、尝试从mAttachedScrap中获取ViewHolder,此时获取的是屏幕中可见范围中的ViewHolder //2、mAttachedScrap缓存中没有的话，继续从mCachedViews尝试获取ViewHolder holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); ----------省略---------- &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); ---------省略---------- final int type = mAdapter.getItemViewType(offsetPosition); //如果Adapter中声明了Id，尝试从id中获取，这里不属于缓存 if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; 3、从自定义缓存mViewCacheExtension中尝试获取ViewHolder，该缓存需要开发者实现 final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); &#125; &#125; if (holder == null) &#123; // fallback to pool //4、从缓存池mRecyclerPool中尝试获取ViewHolder holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; //如果获取成功，会重置ViewHolder状态，所以需要重新执行Adapter#onBindViewHolder绑定数据 holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; ---------省略---------- //5、若以上缓存中都没有找到对应的ViewHolder，最终会调用Adapter中的onCreateViewHolder创建一个 holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); //6、如果需要绑定数据，会调用Adapter#onBindViewHolder来绑定数据 bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; ----------省略---------- return holder;&#125; 上述逻辑用流程图表示： 总结一下上述流程：通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局及绑定数据；通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。 ViewCacheExtension我们已经知道ViewCacheExtension属于第三级缓存，需要开发者自行实现，那么ViewCacheExtension在什么场景下使用？又是如何实现的呢？ 首先我们要明确一点，那就是Recycler本身已经设置了好几级缓存了，为什么还要留个接口让开发者去自行实现缓存呢？关于这一点，谈一谈我的理解：来看看Recycler中的其他缓存，其中mAttachedScrap用来处理可见屏幕的缓存；mCachedViews里存储的数据虽然是根据position来缓存，但是里面的数据随时可能会被替换的；再来看mRecyclerPool，mRecyclerPool里按viewType去存储ArrayList&lt; ViewHolder&gt;，所以mRecyclerPool并不能按position去存储ViewHolder，而且从mRecyclerPool取出的View每次都要去走Adapter#onBindViewHolder去重新绑定数据。假如我现在需要在一个特定的位置(比如position&#x3D;0位置)一直展示某个View，且里面的内容是不变的，那么最好的情况就是在特定位置时，既不需要每次重新创建View，也不需要每次都去重新绑定数据，上面的几种缓存显然都是不适用的，这种情况该怎么办呢？可以通过自定义缓存ViewCacheExtension实现上述需求。 ViewCacheExtension适用场景：ViewHolder位置固定、内容固定、数量有限时使用 ViewCacheExtension使用举例：比如在position = 0时展示的是一个广告，位置不变，内容不变，来看看如何实现：1234567891011121314151617181920212223242526272829303132 //DemoRvActivity.java: public class DemoRvActivity extends AppCompatActivity &#123; private RecyclerView recyclerView; private DemoAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo_rv); recyclerView = findViewById(R.id.rv_view); recyclerView.setLayoutManager(new LinearLayoutManager(this)); recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); adapter = new DemoAdapter(); recyclerView.setAdapter(adapter); //viewType类型为TYPE_SPECIAL时，设置四级缓存池RecyclerPool不存储对应类型的数据 因为需要开发者自行缓存 recyclerView.getRecycledViewPool().setMaxRecycledViews(DemoAdapter.TYPE_SPECIAL, 0); //设置ViewCacheExtension缓存 recyclerView.setViewCacheExtension(new MyViewCacheExtension()); &#125; //实现自定义缓存ViewCacheExtension class MyViewCacheExtension extends RecyclerView.ViewCacheExtension &#123; @Nullable @Override public View getViewForPositionAndType(@NonNull RecyclerView.Recycler recycler, int position, int viewType) &#123; //如果viewType为TYPE_SPECIAL,使用自己缓存的View去构建ViewHolder // 否则返回null，会使用系统RecyclerPool缓存或者从新通过onCreateViewHolder构建View及ViewHolder return viewType == DemoAdapter.TYPE_SPECIAL ? adapter.caches.get(position) : null; &#125; &#125;&#125; 在看下Adapter的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class DemoAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; //viewType类型 TYPE_COMMON代表普通类型 TYPE_SPECIAL代表特殊类型(此处的View和数据一直不变) public static final int TYPE_COMMON = 1; public static final int TYPE_SPECIAL = 101; public SparseArray&lt;View&gt; caches = new SparseArray&lt;&gt;();//开发者自行维护的缓存 private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); DemoAdapter() &#123; initData(); &#125; private void initData() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (i == 0) &#123; mDatas.add(&quot;我是一条特殊的数据，我的位置固定、内容不会变&quot;); &#125; else &#123; mDatas.add(&quot;这是第&quot; + (i + 1) + &quot;条数据&quot;); &#125; &#125; &#125; public List&lt;String&gt; getData() &#123; return mDatas; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) &#123; Log.e(&quot;TTT&quot;, &quot;-----onCreateViewHolder:&quot; + &quot;viewType is &quot; + viewType + &quot;-----&quot;); Context context = viewGroup.getContext(); if (viewType == TYPE_SPECIAL) &#123; View view = LayoutInflater.from(context) .inflate(R.layout.item_special_layout, viewGroup, false); return new SpecialHolder(view); &#125; else &#123; View view = LayoutInflater.from(context) .inflate(R.layout.item_common_layout, viewGroup, false); return new CommonHolder(view); &#125; &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; Log.e(&quot;TTT&quot;, &quot;-----onBindViewHolder:&quot; + &quot;position is &quot; + position + &quot;-----&quot;); if (holder instanceof SpecialHolder) &#123; SpecialHolder sHolder = (SpecialHolder) holder; sHolder.tv_ad.setText(mDatas.get(position)); //这里是重点，根据position将View放到自定义缓存中 caches.put(position, sHolder.itemView); &#125; else if (holder instanceof CommonHolder) &#123; CommonHolder cHolder = (CommonHolder) holder; cHolder.tv_textName.setText(mDatas.get(position)); &#125; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return TYPE_SPECIAL;//第一个位置View和数据固定 &#125; else &#123; return TYPE_COMMON; &#125; &#125; @Override public long getItemId(int position) &#123; return super.getItemId(position); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; class SpecialHolder extends RecyclerView.ViewHolder &#123; TextView tv_ad; public SpecialHolder(@NonNull View itemView) &#123; super(itemView); tv_ad = itemView.findViewById(R.id.tv_special_ad); &#125; &#125; class CommonHolder extends RecyclerView.ViewHolder &#123; TextView tv_textName; public CommonHolder(@NonNull View itemView) &#123; super(itemView); tv_textName = itemView.findViewById(R.id.tv_text); &#125; &#125;&#125; 运行界面如下： 重点关注第一条数据，当第一次运行时，在针对于第一条数据会执行Adapter#onCreateViewHolder和Adapter#onBindViewHolder，想想也对，毕竟第一次执行，肯定要有一个创建View和绑定数据的过程。此时向下滑动到底部再滑上来，通过debug发现不再走这两个方法了，而是在getViewForPositionAndType回调中根据position拿到了我们自定义缓存中的View及数据，所以可以直接展示。我们自行维护的缓存是什么时候设置的，其实这里是在Adapter#onBindViewHolder中根据position设置的缓存： 1caches.put(position, sHolder.itemView); 假如我们把上面这行代码删除了呢，再次执行上述滑动操作，自定义缓存对应失效了，Adapter#onCreateViewHolder和Adapter#onBindViewHolder都会被执行，这里可能大家可能会有个疑问，自定义缓存失效，为什么RecyclerPool里也没有对这个viewType进行缓存呢(因为如果缓存了，是不会重新执行onCreateViewHolder的)？猜想这是因为我在代码中设置了 1recyclerView.getRecycledViewPool().setMaxRecycledViews(DemoAdapter.TYPE_SPECIAL, 0) 即viewType类型为TYPE_SPECIAL时，设置缓存池RecyclerPool不存储对应类型的数据，因为开发者自行缓存了，所以没必要再往RecyclerPool存储了，如果把上面这行代码注释掉，重新执行上述滑动操作，会发现针对第一条数据只执行了Adapter#onBindViewHolder，因为即使自定义缓存失效了，默认还是会往RecyclerPool存储的嘛，这也验证了我们的猜想。 RecyclerView &amp; ListView缓存机制对比结论援引自：Android ListView 与 RecyclerView 对比浅析–缓存机制 ListView和RecyclerView缓存机制基本一致：1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView； 2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用. 3). RecyclerView的优势在于a.mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；b.mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势.客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。不同使用场景：列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。 参考【1】关于Recyclerview的缓存机制的理解【2】RecyclerView缓存机制【3】ViewCacheExtension使用【4】RecyclerView 必知必会 【5】https://juejin.im/post/5a7569676fb9a063435eaf4c【6】https://github.com/gyzboy/AndroidSamples/blob/master/app/src/main/java/com/gyz/androidsamples/view/ASRecyclerView.java【7】https://blog.csdn.net/HJsir/article/details/81485653【8】RecyclerView缓存原理，有图有真相","tags":["RecyclerView缓存机制"],"categories":["源码解析, View系列"]}]