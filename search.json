[{"title":"Android Studio中通过SSH Key上传代码到Github","path":"/2023/04/10/Android-Studio中通过SSH-Key上传代码到Github/","content":"GitHub中的SSH配置我们在日常开发中请求登录后，服务端会根据登录信息生成一个该用户的唯一标识，如sessionId或者token，后续客户端请求其他接口时，只需要将该标识传给服务端即可，而不用每次再重新登录。 类似的，如果往Github上push项目的时候，不想每次都输入账号密码，那么就可以采用\tSSH的方式，只需要在Github自己账号下配置一个SSH Key即可！ 一 检查SSH Key信息在控制台打开ssh目录： 1cd ~/.ssh 然后输入ls命令查看该目录下是否有文件，如在我的电脑中：因为我之前生成过，所以这里直接列出了之前生成的SSH Key，其中id_ed25519是私钥，id_ed25519.pub是公钥。通过open ~/.ssh命令打开该目录，可以看到对应文件： 二 生成SSH Key信息上一节是存在SSH Key 的情况，如果之前没有生成过，则需要我们先生成一下： 1ssh-keygen -t ed25519 -C &quot;xxx@xxx.com&quot; t ：指定要使用的密钥算法类型，可选dsa | ecdsa | ed25519 | rsa非对称加密算法其中的一种。 C : 用于在生成的SSH 密钥文件中添加注释信息，方便用户识别和管理，这个注释信息会被添加到生成的 SSH 密钥文件的结尾处，一般使用Email 邮箱来添加注释信息。 现在我把之前的.ssh目录下的签名信息全部删除，重新生成一遍，如执行下面的命令： 1ssh-keygen -t ed25519 -C &quot;504091986@qq.com&quot; 一路点击回车，执行结果： 这样会在 .ssh 目录重新生成两个文件：id_id_ed25519和id_id_ed25519.pub 其中id_id_ed25519 文件是私有密钥，id_id_ed25519.pub是公开密钥。 三 获取SSH Key里的公钥内容执行下面的命令： cat ~&#x2F;.ssh&#x2F;id_ed25519.pub 执行结果： 1ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOZQf7wE5XxUB3YnEZ4MjqA7F8aze2rq5jM0uo3xxxxx 504091986@qq.com 上面就是我们生成的公钥了，当然也可以直接进入的.ssh目录下，打开 id_ed25519.pub 文件，也可以看到公钥中的内容。 四 Github上配置公钥打开对应的项目工程，然后按下面的步骤配置：如上面截图所示，依次点击Settings -&gt; Deploy keys，在显示的页面上，Title 随便起个名字，重点是 Key，将上一节生成的公钥拷贝到这里，下面的 Allow writes acess 打上勾，点击 Add key 按钮就可以了。 验证是否设置成功 1ssh -T git@github.com 如果返回下面的提示则表示设置成功了： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 后续就可以在Android Studio中直接通过git操作远程代码仓库了。"},{"title":"Android | 深入理解RecyclerView缓存机制","path":"/2023/04/10/Android-深入理解RecyclerView缓存机制/","content":"RecyclerView在项目中的使用已经很普遍了，可以说是项目中最高频使用的一个控件了。除了布局灵活性、丰富的动画，RecyclerView还有优秀的缓存机制，本文尝试通过源码深入了解一下RecyclerView中的缓存机制。 写在前面RecyclerView 是通过内部类 Recycler 管理的缓存，那么 Recycler 中缓存的是什么？我们知道 RecyclerView 在存在大量数据时依然可以滑动的如丝滑般顺畅，而 RecyclerView 本身是一个 ViewGroup ，那么滑动时避免不了添加或移除子View(子View通过RecyclerView#Adapter中的onCreateViewHolder创建)，如果每次使用子View都要去重新创建，肯定会影响滑动的流 畅性，所以 RecyclerView 通过 Recycler 来缓存的是 ViewHolder (内部包含子View)，这样在滑动时可以复用子View，某些条件下还可以复用子View绑定的数据。所以本质上缓存是为了减少重复绘制View和绑定数据的时间，从而提高了滑动时的性能。 四级缓存Recycler缓存ViewHolder对象有4个等级，优先级从高到底依次为： mAttachedScrap：ArrayList&lt; ViewHolder&gt;类型 mCachedViews：ArrayList&lt; ViewHolder&gt;类型 mViewCacheExtension：ViewCacheExtension类型 mRecyclerPool：RecycledViewPool类型 注：官方上把mAttachedScrap、mCachedViews当成一级了，为了方便区分，本文还是把他们当成两级缓存。 缓存 涉及对象 作用 重新创建视图View(onCreateViewHolder) 重新绑定数据(onBindViewHolder) 一级缓存 mAttachedScrap 缓存屏幕中可见范围的ViewHolder false false 二级缓存 mCachedViews 缓存滑动时即将与RecyclerView分离的ViewHolder，按子View的position或id缓存，默认最多存放2个 false false 三级缓存 mViewCacheExtension 开发者自行实现的缓存 - - 四级缓存 mRecyclerPool ViewHolder缓存池，本质上是一个SparseArray，其中key是ViewType(int类型)，value存放的是 ArrayList&lt; ViewHolder&gt;，默认每个ArrayList中最多存放5个ViewHolder false true RecyclerView 滑动时会触发 onTouchEvent#onMove ，回收及复用 ViewHolder 在这里就会开始。我们知道设置 RecyclerView 时需要设置 LayoutManager， LayoutManager 负责 RecyclerView 的布局，包含对 ItemView 的获取与复用。以LinearLayoutManager为例，当 RecyclerView 重新布局时会依次执行下面几个方法： onLayoutChildren()：对RecyclerView进行布局的入口方法 fill(): 负责对剩余空间不断地填充，调用的方法是layoutChunk() layoutChunk()：负责填充View,该View最终是通过在缓存类Recycler中找到合适的View 上述的整个调用链：**onLayoutChildren()-&gt;fill()-&gt;layoutChunk()-&gt;next()-&gt;getViewForPosition()**，getViewForPosition()即是是从RecyclerView的回收机制实现类Recycler中获取合适的View，下面主要就来从看这个Recycler#getViewForPosition()的实现。 12345678@NonNullpublic View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125; 他们都会执行tryGetViewHolderForPositionByDeadline函数，继续跟进去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//根据传入的position获取ViewHolderViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; ---------省略---------- boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; //预布局 属于特殊情况 从mChangedScrap中获取ViewHolder if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; if (holder == null) &#123; //1、尝试从mAttachedScrap中获取ViewHolder,此时获取的是屏幕中可见范围中的ViewHolder //2、mAttachedScrap缓存中没有的话，继续从mCachedViews尝试获取ViewHolder holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); ----------省略---------- &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); ---------省略---------- final int type = mAdapter.getItemViewType(offsetPosition); //如果Adapter中声明了Id，尝试从id中获取，这里不属于缓存 if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; 3、从自定义缓存mViewCacheExtension中尝试获取ViewHolder，该缓存需要开发者实现 final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); &#125; &#125; if (holder == null) &#123; // fallback to pool //4、从缓存池mRecyclerPool中尝试获取ViewHolder holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; //如果获取成功，会重置ViewHolder状态，所以需要重新执行Adapter#onBindViewHolder绑定数据 holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; ---------省略---------- //5、若以上缓存中都没有找到对应的ViewHolder，最终会调用Adapter中的onCreateViewHolder创建一个 holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); //6、如果需要绑定数据，会调用Adapter#onBindViewHolder来绑定数据 bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; ----------省略---------- return holder;&#125; 上述逻辑用流程图表示： 总结一下上述流程：通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局及绑定数据；通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。 ViewCacheExtension我们已经知道ViewCacheExtension属于第三级缓存，需要开发者自行实现，那么ViewCacheExtension在什么场景下使用？又是如何实现的呢？ 首先我们要明确一点，那就是Recycler本身已经设置了好几级缓存了，为什么还要留个接口让开发者去自行实现缓存呢？关于这一点，谈一谈我的理解：来看看Recycler中的其他缓存，其中mAttachedScrap用来处理可见屏幕的缓存；mCachedViews里存储的数据虽然是根据position来缓存，但是里面的数据随时可能会被替换的；再来看mRecyclerPool，mRecyclerPool里按viewType去存储ArrayList&lt; ViewHolder&gt;，所以mRecyclerPool并不能按position去存储ViewHolder，而且从mRecyclerPool取出的View每次都要去走Adapter#onBindViewHolder去重新绑定数据。假如我现在需要在一个特定的位置(比如position&#x3D;0位置)一直展示某个View，且里面的内容是不变的，那么最好的情况就是在特定位置时，既不需要每次重新创建View，也不需要每次都去重新绑定数据，上面的几种缓存显然都是不适用的，这种情况该怎么办呢？可以通过自定义缓存ViewCacheExtension实现上述需求。 ViewCacheExtension适用场景：ViewHolder位置固定、内容固定、数量有限时使用 ViewCacheExtension使用举例：比如在position = 0时展示的是一个广告，位置不变，内容不变，来看看如何实现：1234567891011121314151617181920212223242526272829303132 //DemoRvActivity.java: public class DemoRvActivity extends AppCompatActivity &#123; private RecyclerView recyclerView; private DemoAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo_rv); recyclerView = findViewById(R.id.rv_view); recyclerView.setLayoutManager(new LinearLayoutManager(this)); recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); adapter = new DemoAdapter(); recyclerView.setAdapter(adapter); //viewType类型为TYPE_SPECIAL时，设置四级缓存池RecyclerPool不存储对应类型的数据 因为需要开发者自行缓存 recyclerView.getRecycledViewPool().setMaxRecycledViews(DemoAdapter.TYPE_SPECIAL, 0); //设置ViewCacheExtension缓存 recyclerView.setViewCacheExtension(new MyViewCacheExtension()); &#125; //实现自定义缓存ViewCacheExtension class MyViewCacheExtension extends RecyclerView.ViewCacheExtension &#123; @Nullable @Override public View getViewForPositionAndType(@NonNull RecyclerView.Recycler recycler, int position, int viewType) &#123; //如果viewType为TYPE_SPECIAL,使用自己缓存的View去构建ViewHolder // 否则返回null，会使用系统RecyclerPool缓存或者从新通过onCreateViewHolder构建View及ViewHolder return viewType == DemoAdapter.TYPE_SPECIAL ? adapter.caches.get(position) : null; &#125; &#125;&#125; 在看下Adapter的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class DemoAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; //viewType类型 TYPE_COMMON代表普通类型 TYPE_SPECIAL代表特殊类型(此处的View和数据一直不变) public static final int TYPE_COMMON = 1; public static final int TYPE_SPECIAL = 101; public SparseArray&lt;View&gt; caches = new SparseArray&lt;&gt;();//开发者自行维护的缓存 private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); DemoAdapter() &#123; initData(); &#125; private void initData() &#123; for (int i = 0; i &lt; 50; i++) &#123; if (i == 0) &#123; mDatas.add(&quot;我是一条特殊的数据，我的位置固定、内容不会变&quot;); &#125; else &#123; mDatas.add(&quot;这是第&quot; + (i + 1) + &quot;条数据&quot;); &#125; &#125; &#125; public List&lt;String&gt; getData() &#123; return mDatas; &#125; @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) &#123; Log.e(&quot;TTT&quot;, &quot;-----onCreateViewHolder:&quot; + &quot;viewType is &quot; + viewType + &quot;-----&quot;); Context context = viewGroup.getContext(); if (viewType == TYPE_SPECIAL) &#123; View view = LayoutInflater.from(context) .inflate(R.layout.item_special_layout, viewGroup, false); return new SpecialHolder(view); &#125; else &#123; View view = LayoutInflater.from(context) .inflate(R.layout.item_common_layout, viewGroup, false); return new CommonHolder(view); &#125; &#125; @Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) &#123; Log.e(&quot;TTT&quot;, &quot;-----onBindViewHolder:&quot; + &quot;position is &quot; + position + &quot;-----&quot;); if (holder instanceof SpecialHolder) &#123; SpecialHolder sHolder = (SpecialHolder) holder; sHolder.tv_ad.setText(mDatas.get(position)); //这里是重点，根据position将View放到自定义缓存中 caches.put(position, sHolder.itemView); &#125; else if (holder instanceof CommonHolder) &#123; CommonHolder cHolder = (CommonHolder) holder; cHolder.tv_textName.setText(mDatas.get(position)); &#125; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return TYPE_SPECIAL;//第一个位置View和数据固定 &#125; else &#123; return TYPE_COMMON; &#125; &#125; @Override public long getItemId(int position) &#123; return super.getItemId(position); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; class SpecialHolder extends RecyclerView.ViewHolder &#123; TextView tv_ad; public SpecialHolder(@NonNull View itemView) &#123; super(itemView); tv_ad = itemView.findViewById(R.id.tv_special_ad); &#125; &#125; class CommonHolder extends RecyclerView.ViewHolder &#123; TextView tv_textName; public CommonHolder(@NonNull View itemView) &#123; super(itemView); tv_textName = itemView.findViewById(R.id.tv_text); &#125; &#125;&#125; 运行界面如下： 重点关注第一条数据，当第一次运行时，在针对于第一条数据会执行Adapter#onCreateViewHolder和Adapter#onBindViewHolder，想想也对，毕竟第一次执行，肯定要有一个创建View和绑定数据的过程。此时向下滑动到底部再滑上来，通过debug发现不再走这两个方法了，而是在getViewForPositionAndType回调中根据position拿到了我们自定义缓存中的View及数据，所以可以直接展示。我们自行维护的缓存是什么时候设置的，其实这里是在Adapter#onBindViewHolder中根据position设置的缓存： 1caches.put(position, sHolder.itemView); 假如我们把上面这行代码删除了呢，再次执行上述滑动操作，自定义缓存对应失效了，Adapter#onCreateViewHolder和Adapter#onBindViewHolder都会被执行，这里可能大家可能会有个疑问，自定义缓存失效，为什么RecyclerPool里也没有对这个viewType进行缓存呢(因为如果缓存了，是不会重新执行onCreateViewHolder的)？猜想这是因为我在代码中设置了 1recyclerView.getRecycledViewPool().setMaxRecycledViews(DemoAdapter.TYPE_SPECIAL, 0) 即viewType类型为TYPE_SPECIAL时，设置缓存池RecyclerPool不存储对应类型的数据，因为开发者自行缓存了，所以没必要再往RecyclerPool存储了，如果把上面这行代码注释掉，重新执行上述滑动操作，会发现针对第一条数据只执行了Adapter#onBindViewHolder，因为即使自定义缓存失效了，默认还是会往RecyclerPool存储的嘛，这也验证了我们的猜想。 RecyclerView &amp; ListView缓存机制对比结论援引自：Android ListView 与 RecyclerView 对比浅析–缓存机制 ListView和RecyclerView缓存机制基本一致：1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView； 2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用. 3). RecyclerView的优势在于a.mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；b.mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势.客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。不同使用场景：列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。 参考【1】关于Recyclerview的缓存机制的理解【2】RecyclerView缓存机制【3】ViewCacheExtension使用【4】RecyclerView 必知必会 【5】https://juejin.im/post/5a7569676fb9a063435eaf4c【6】https://github.com/gyzboy/AndroidSamples/blob/master/app/src/main/java/com/gyz/androidsamples/view/ASRecyclerView.java【7】https://blog.csdn.net/HJsir/article/details/81485653【8】RecyclerView缓存原理，有图有真相"}]